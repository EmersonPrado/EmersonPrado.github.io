---
layout: default
---

<body>
  <a href="3_code_data_pt.html">Português</a>

  <h1>Efficient Vagrantfiles – Part 3 – Code and data separation</h1>

  <p>In the <a href="2_ruby.html">second part</a> of this series, we got rid of lots of repeated code (and open doors for typing mistakes) by using arrays, hashes, loops and conditionals. Now, let's get our code cleaner and make maintenance more focused by getting code and data where each one belongs.</p>

  <ol>
    <li><a href="#tldr">TL;DR</a></li>
    <li><a href="#problem">Problem - messing with code to each environment change</a></li>
    <li><a href="#solution">Solution - each thing where it belongs</a>
      <ol>
        <li><a href="#variables">Variables versus logic</a></li>
        <li><a href="#yaml">Yaml</a></li>
      </ol>
    </li>
    <li><a href="#together">Putting pieces together</a></li>
    <li><a href="#where">Where do we go from here?</a></li>
  </ol>

  <h2 id="#tldr">TL;DR</h2>
  <h2 id="#problem">Problem - messing with code to each environment change</h2>

  <p>Your environment will change. Period. You might have to test an application's new version, or debug something in it, or try it in more OS options, or update boxes, etc. That's one of the main reasons you're using Vagrant in first place. In the common Vagrant use, every change means editing your Vagrantfile. This means trouble because:</p>
  <ul>
    <li>You end up sometimes having a big Vagrantfile with everything in it. Changing things becomes increasingly more difficult.</li>
    <li>When you have to think about code, you see data too. When you edit code, you risk messing data too. And vice-versa.</li>
    <li>Reusing Vagrantfiles becomes tedious - you have to remove all original data from the cloned Vagrantfile.</li>
    <li>Version tracking becomes a mess - no matter what had to change, your versioning system will always show the same change: Vagrantfile.</li>
  </ul>

  <h2 id="#solution">Solution - each thing where it belongs</h2>

  <p>If the problem is data and code mixed up, the solution is obvious: let's take them apart. We'll accomplish this in two steps: taking data and code to different Vagrantfile sections, then actually removing data from it.</p>

  <h3 id="#variables">Variables versus logic</h3>

  <p>The first part is fairly easy. For us to move data upwards in the Vagrantfile, all we have to do is setting variables before we write logic. Like:</p>

  <pre>
  # Data and code together
  $ ruby -e '
  {1 => "a", 2 => "b", 3 => "c"}.each do |key, value|
    puts "Key: #{key} - Value: #{value}"
  end
  '
  Key: 1 - Value: a
  Key: 2 - Value: b
  Key: 3 - Value: c

  # Data first, stored in a variable, then the code using it
  $ ruby -e '
  stuff = {1 => "a", 2 => "b", 3 => "c"}
  # Whatever
  stuff.each do |key, value|
    puts "Key: #{key} - Value: #{value}"
  end
  '
  Key: 1 - Value: a
  Key: 2 - Value: b
  Key: 3 - Value: c
  </pre>

  <p>I agree it didn't get quite neater - it got somewhat longer indeed. But it is more organized and focused. We just don't have a method and a code block around when we have to think about the data, nor a hash, or whatever data structure, when we have to think about the code. Just think about the huge hash we were dealing with in the last example of part 2, and the advantage becomes more clear.</p>

  <h3 id="#yaml">Yaml</h3>
  <h2 id="#together">Putting pieces together</h2>
  <h2 id="#where">Where do we go from here?</h2>
</body>
