---
layout: default
---

<body>
  <a href="../index.html">Start page</a><br>
  <a href="3_code_data_pt.html">Português</a>

  <h1>Efficient Vagrantfiles – Part 3 – Code and data separation</h1>

  <p>In the <a href="2_ruby.html">second part</a> of this series, we got rid of lots of repeated code (and open doors for typing mistakes) by using arrays, hashes, loops and conditionals. Now, let's get our code cleaner and make maintenance more focused by getting code and data where each one belongs.</p>

  <ol>
    <li><a href="#tldr">TL;DR</a></li>
    <li><a href="#problem">Problem - messing with code to each environment change</a></li>
    <li><a href="#solution">Solution - each thing where it belongs</a>
      <ol>
        <li><a href="#variables">Variables versus logic</a></li>
        <li><a href="#yaml">Yaml</a><ol>
          <li><a href="#yaml_basics">Basics</a></li>
          <li><a href="#yaml_nesting">Nesting</a></li>
          <li><a href="#yaml_hints">Hints</a></li>
        </ol></li>
      </ol>
    </li>
    <li><a href="#together">Putting pieces together</a>
      <ol>
        <li><a href="#settings">More settings</a></li>
        <li><a href="#datafiles">More data files</a></li>
      </ol>
    </li>
    <li><a href="#where">Where do we go from here?</a></li>
  </ol>

  <h2 id="tldr">TL;DR</h2>

  <p>If you already know about YAML files and how they're loaded into Ruby code, you might skip this part of the articles, and get going with what I've summarized below.</p>

  <p>In part two, we ended with a hash with data for all VMs, then the code with a loop iterating from that hash. The code and data distinction is somewhat clear. Let's create an external file <code>etc/vms.yaml</code>, in YAML format, with that data and some more (stuff I usually needed in my tests):</p>

  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_3:
      :box: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <p>Then, in the Vagrantfile, load this file into a variable, and use this variable in the loop, consuming the various nested keys and values:</p>

  <pre>
    require 'yaml'
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
            confs[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if confs.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>You can further divide the data in multiple files, if they start showing too much repetition. You probably saw (kudos to you!) the VMs file has almost the same data for the VMs that use the same box. So, let's divide it in two files - VMs and boxes:</p>

  <h4>Boxes data file - <code>etc/boxes.yaml</code></h4>
  <pre>
    ---
    debian_jessie:
      :name: ARTACK/debian-jessie
      :ram: 256
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    centos_7:
      :name: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h4>VMs data file - <code>etc/vms.yaml</code></h4>
  <pre>
    ---
    vm_1:
      :box: debian_jessie
      :ip: 192.168.1.2
    vm_2:
      :box: debian_jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos_7
  </pre>

  <h4>Then, the Vagrantfile</h4>
  <pre>
    require 'yaml'
    BOXES = YAML.load_file('etc/boxes.yaml')
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          box = BOXES[confs[:box]]
          vm.vm.box = box[:name]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = box[:ram] if box.has_key?(:ram)
            virtualbox.cpus = box[:cpu] if box.has_key?(:cpu)
            box[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if box.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>Complexity is the limit. You can have a single data file, or many ones dividing the data. Keep in mind the compromise between conciseness and simplicity. Always remember everything should be easy to understand and mantain by other people, including non-developers. Use your good sense and keep up!</p>

  <h2 id="problem">Problem - messing with code to each environment change</h2>

  <p>Your environment will change. Period. You might have to test an application's new version, or debug something in it, or try it in more OS options, or update boxes, etc. That's one of the main reasons you're using Vagrant in first place. In the common Vagrant use, every change means editing your Vagrantfile. This means trouble because:</p>
  <ul>
    <li>You end up sometimes having a big Vagrantfile with everything in it. Changing things becomes increasingly more difficult.</li>
    <li>When you have to edit code, you have data around. And vice-versa. It's harder to focus in just one of them, and easier to mess with the other.</li>
    <li>Reusing Vagrantfiles becomes tedious - you have to copy and paste Vagrantfiles then manually edit changes.</li>
    <li>Version tracking becomes a mess - no matter what had to change, your versioning system will always show the same change: Vagrantfile.</li>
  </ul>

  <h2 id="solution">Solution - each thing where it belongs</h2>

  <p>If the problem is code and data mixed up, the solution is obvious: let's take them apart. We'll accomplish this in two steps: taking code and data to different Vagrantfile sections, then actually removing data from it.</p>

  <h3 id="variables">Variables versus logic</h3>

  <p>The first part is fairly easy. For us to move data upwards in the Vagrantfile, all we have to do is setting variables before we write logic. Like:</p>

  <pre>
  # Code and data together
  $ ruby -e '
  {1 => "a", 2 => "b", 3 => "c"}.each do |key, value|
    puts "Key: #{key} - Value: #{value}"
  end
  '
  Key: 1 - Value: a
  Key: 2 - Value: b
  Key: 3 - Value: c

  # Data first, stored in a variable, then the code using it
  $ ruby -e '
  stuff = {1 => "a", 2 => "b", 3 => "c"}
  # Whatever
  stuff.each do |key, value|
    puts "Key: #{key} - Value: #{value}"
  end
  '
  Key: 1 - Value: a
  Key: 2 - Value: b
  Key: 3 - Value: c
  </pre>

  <p>I agree it didn't get quite neater - it got somewhat longer indeed. But it is more organized and focused. We just don't have a method and a code block around when we have to think about the data, nor a hash, or whatever data structure, when we have to think about the code. Just think about the huge hash we were dealing with in the last example of part 2, and the advantage becomes more clear.</p>

  <h3 id="yaml">Yaml</h3>

  <p>We still have code and data in the same file. Fortunately, we don't have to. Ruby has native support for a structured file format called YAML. So our data can go into such files, finally cleaning our Vagrantfile.</p>
  <p>This is how it works: a YAML file can store a Ruby object, which can be a single value, an array, a hash, or nested arrays/hashes, without much hassle (given you get familiar to the picky format). And Ruby can load an YAML file into a variable.</p>
  <p>So, all we have to do is to create a data file for each data structure, then load them in variables in the Vagrantfile. With only code.</p>

  <h4 id="yaml_basics">Basics</h4>

  <p>The YAML file contents format depends primarily on the type of object it contains:</p>

  <ol>
    <li>Start with a line with 3 dashes. This tells the OS it's an YAML file. Not quite required, but highly recommended.</li>
    <li>For a single value, just put it plainly in the additional line. It could be next to the dashes in the same line, but would look weird.</li>
    <li>For an array, put each item in a line, prepended by one dash and one space. I do mean one. Remember: YAML is picky.</li>
    <li>For a hash, put each key in the beginning of a line, followed by a colon, then space(s), and the value. I do mean the beginning, and also space(s) between the colon and the value. Remember: YAML is picky.</li>
  </ol>

  <p>Examples (each one is a file)</p>

  <pre>
  # A number
  ---
  3.14

  # A string
  ---
  Hello, world!

  # A 2-item array (items classes can vary)
  ---
  - 1
  - Two

  ---
  # A 2-element hash (keys and values classes can vary)
  One: 1
  2: Two
  </pre>

  <h4 id="yaml_nesting">Nesting</h4>

  <p>Just as arrays and hashes can be nested in Ruby objects, so can they in YAML files. Nesting is indicated by indentation, plus some special attention in first items:</p>

  <ol>
    <li>Start "outer" objects as normal, but omitting the contents - the array item or the hash value. That is:<ol>
      <li>For an "outer" array, just put the dash</li>
      <li>For an "outer" hash, just put the key and the colon</li>
    </ol></li>
    <li>Indent "inner" objects with two spaces. I do mean two. Remember: YAML is picky.</li>
    <li>For additional nesting, do exactly the same, but indented with two additional spaces per depth level. I do mean two. Remember: YAML is picky.</li>
    <li>Never indent with tabs. Ever! Don't know if I already warned you, but YAML is picky.</li>
  </ol>

  <h4 id="yaml_hints">Hints</h4>

  <h2 id="together">Putting pieces together</h2>
  <p>Let's use the dump feature with the hash from our Vagrantfile. But, instead of seeing the output in the screen, let's write it to a virtual machines list file:</p>
  <pre>
    # A config dir in our project
    # What better name then "etc"?
    mkdir etc

    ruby -e "
      require 'yaml'
      IO.write('etc/vms.yaml', YAML.dump({
        'vm_1' => {
          :box => 'ARTACK/debian-jessie',
          :ip => '192.168.1.2'
        },
        'vm_2' => {
          :box => 'ARTACK/debian-jessie',
          :ip => '192.168.1.3'
        },
        'vm_3' => {
          :box => 'centos/7'
        }
      }))
    "

    cat etc/vms.yaml
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ip: 192.168.1.2
    vm_2:
      :box: ARTACK/debian-jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos/7
  </pre>

  <p>Nice! Half way done. Now on the second half: instructing Vagrant to read the file. It's the same, but the other way round:</p>
  <blockquote>We'll load the data into constants - just begin variables names with capitals and Ruby knows they're constants. There's no sense in changing their values thoughout the Vagrantfile.</blockquote>
  <pre>
    require 'yaml'
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
        end
      end
    end
  </pre>

  <p>Done! We have two slim and readable files, one with code and another one with data. You don't touch the Vagrantfile anymore to change VMs.</p>

  <h3 id="settings">More settings</h3>

  <p>Yes, sure a virtual machine is not about only name and IPs. Maybe you need to change RAM and/or CPU settings, for example?</p>

  <pre>
    require 'yaml'
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
          end
        end
      end
    end
  </pre>

  <p>Then, in the data file:</p>
  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
    vm_3:
      :box: centos/7
      :cpu: 2
  </pre>

  <p>In my case, I needed some VirtualBox custom settings. In Vagrant, this is done by passing a setting name and a value into <code>virtualbox.customize</code> tag.</p>

  <pre>
    require 'yaml'
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
            confs[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if confs.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>That was the code, still independent from the settings themselves (no data in code!). Now, in the datafile, let's disable USB and VirtualBox Remote Desktop Extension, which already gave me pain in some VMs:</p>
  <blockquote>For the custom settings, we need names and values, which means a hash as the value for the ':custom' key</blockquote>
  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_3:
      :box: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h3 id="datafiles">More data files</h3>

  <p>I heard you say "Hey, there's too much repetition in the data files!". That makes me proud of you.</p>
  <p>Yes, there are settings that will repeat. All VMs from the same box use at least the same box name and version. Sometimes, same resources and/or custom settings. Why repeat them all if we can have a data file for the boxes themselves?</p>

  <h4>Boxes data file</h4>
  <pre>
    ---
    debian_jessie:
      :name: ARTACK/debian-jessie
      :ram: 256
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    centos_7:
      :name: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h4>VMs data file</h4>
  <pre>
    ---
    vm_1:
      :box: debian_jessie
      :ip: 192.168.1.2
    vm_2:
      :box: debian_jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos_7
  </pre>

  <h4>Then, the Vagrantfile</h4>
  <pre>
    require 'yaml'
    BOXES = YAML.load_file('etc/boxes.yaml')
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          box = BOXES[confs[:box]]
          vm.vm.box = box[:name]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = box[:ram] if box.has_key?(:ram)
            virtualbox.cpus = box[:cpu] if box.has_key?(:cpu)
            box[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if box.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>There's no hard line telling which files you should have and which data should be in each one. Go for the best bet between flexibility and simplicity.</p>
  <br>
  <p>Now we have 3 files with less than 20 lines each, all of them quite readable, and that gets us 3 VMs with different OSs, RAM and CPU settings, IP and virtualizer specific stuff. And that we can very easily change, extend and/or reuse. Happy? Me too.</p>

  <h2 id="where">Where do we go from here?</h2>

  <p>What else can go in its own file and be consumed by the code? Maybe common hardware settings, network, some provisioning?</p>
  <p>Look for repeating patterns. We took code and data apart at all when it became clear that the code was almost the same to all VMs. Then created the boxes file when VMs settings also seemed repetitive. That's the way to go.</p>
  <p>It's not a good idea, though, to place every single repetiion pattern in distinct files. In some cases, you can end up with too many files with too little content and a file and variable maze to develop in.</p>
  <p>The most important thing to keep in mind about dividing all data in their files is that this should always make maintenance easier. Other people, sometimes not Ruby developers, and even you months later, should be able to (re)use your Vagrantfile. If you changed the data architecture, and it seems more complicated, it probably is - Even more to those who didn't write it. Redo or undo.</p>

  <p>Now you know why and how to separate data from code, hands on! Happy Vagrantfiles!</p>

</body>
