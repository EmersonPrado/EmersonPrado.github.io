---
layout: default
---

<body>
  <a href="../index.html">Start page</a><br>
  <a href="3_code_data_pt.html">Português</a>

  <h1>Efficient Vagrantfiles – Part 3 – Code and data separation</h1>

  <p>In the <a href="2_ruby.html">second part</a> of this series, we got rid of lots of repeated code (and open doors for typing mistakes) by using arrays, hashes, loops and conditionals. Now, let's get our code cleaner and make maintenance more focused by getting code and data where each one belongs.</p>

  <ol>
    <li><a href="#tldr">TL;DR</a></li>
    <li><a href="#problem">Problem - messing with code to each environment change</a></li>
    <li><a href="#solution">Solution - each thing where it belongs</a>
      <ol>
        <li><a href="#variables">Variables versus logic</a></li>
        <li><a href="#yaml">Yaml</a></li>
      </ol>
    </li>
    <li><a href="#together">Putting pieces together</a>
      <ol>
        <li><a href="#settings">More settings</a></li>
        <li><a href="#datafiles">More data files</a></li>
      </ol>
    </li>
    <li><a href="#where">Where do we go from here?</a></li>
  </ol>

  <h2 id="tldr">TL;DR</h2>

  <p>If you already know about YAML files and how they're loaded into Ruby code, you might skip this part of the articles, and get going with what I've summarized below.</p>

  <p>In part two, we ended with a hash with data for all VMs, then the code with a loop iterating from that hash. The code and data distinction is somewhat clear. Let's create an external file `etc/vms.yaml`, in YAML format, with that data and some more (stuff I usually needed in my tests):</p>

  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_3:
      :box: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <p>Then, in the Vagrantfile, load this file into a variable, and use this variable in the loop, consuming the various nested keys and values:</p>

  <pre>
    require 'yaml'
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
            confs[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if confs.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>You can further divide the data in multiple files, if they start showing too much repetition. You probably saw (kudos to you!) the VMs file has almost the same data for the VMs that use the same box. So, let's divide it in two files - VMs and boxes:</p>

  <h4>Boxes data file - `etc/boxes.yaml`</h4>
  <pre>
    ---
    debian_jessie:
      :name: ARTACK/debian-jessie
      :ram: 256
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    centos_7:
      :name: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h4>VMs data file - `etc/vms.yaml`</h4>
  <pre>
    ---
    vm_1:
      :box: debian_jessie
      :ip: 192.168.1.2
    vm_2:
      :box: debian_jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos_7
  </pre>

  <h4>Then, the Vagrantfile</h4>
  <pre>
    require 'yaml'
    BOXES = YAML.load_file('etc/boxes.yaml')
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          box = BOXES[confs[:box]]
          vm.vm.box = box[:name]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = box[:ram] if box.has_key?(:ram)
            virtualbox.cpus = box[:cpu] if box.has_key?(:cpu)
            box[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if box.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>Complexity is the limit. You can have a single data file, or many ones dividing the data. Keep in mind the compromise between conciseness and simplicity. Always remember everything should be easy to understand and mantain by other people, including non-developers. Use your good sense and keep up!</p>

  <h2 id="problem">Problem - messing with code to each environment change</h2>

  <p>Your environment will change. Period. You might have to test an application's new version, or debug something in it, or try it in more OS options, or update boxes, etc. That's one of the main reasons you're using Vagrant in first place. In the common Vagrant use, every change means editing your Vagrantfile. This means trouble because:</p>
  <ul>
    <li>You end up sometimes having a big Vagrantfile with everything in it. Changing things becomes increasingly more difficult.</li>
    <li>When you have to edit code, you have data around. And vice-versa. It's harder to focus in just one of them, and easier to mess with the other.</li>
    <li>Reusing Vagrantfiles becomes tedious - you have to copy and paste Vagrantfiles then manually edit changes.</li>
    <li>Version tracking becomes a mess - no matter what had to change, your versioning system will always show the same change: Vagrantfile.</li>
  </ul>

  <h2 id="solution">Solution - each thing where it belongs</h2>

  <p>If the problem is code and data mixed up, the solution is obvious: let's take them apart. We'll accomplish this in two steps: taking code and data to different Vagrantfile sections, then actually removing data from it.</p>

  <h3 id="variables">Variables versus logic</h3>

  <p>The first part is fairly easy. For us to move data upwards in the Vagrantfile, all we have to do is setting variables before we write logic. Like:</p>

  <pre>
  # Code and data together
  $ ruby -e '
  {1 => "a", 2 => "b", 3 => "c"}.each do |key, value|
    puts "Key: #{key} - Value: #{value}"
  end
  '
  Key: 1 - Value: a
  Key: 2 - Value: b
  Key: 3 - Value: c

  # Data first, stored in a variable, then the code using it
  $ ruby -e '
  stuff = {1 => "a", 2 => "b", 3 => "c"}
  # Whatever
  stuff.each do |key, value|
    puts "Key: #{key} - Value: #{value}"
  end
  '
  Key: 1 - Value: a
  Key: 2 - Value: b
  Key: 3 - Value: c
  </pre>

  <p>I agree it didn't get quite neater - it got somewhat longer indeed. But it is more organized and focused. We just don't have a method and a code block around when we have to think about the data, nor a hash, or whatever data structure, when we have to think about the code. Just think about the huge hash we were dealing with in the last example of part 2, and the advantage becomes more clear.</p>

  <h3 id="yaml">Yaml</h3>

  <p>We still have code and data in the same file. Fortunately, we don't have to. Ruby has native support for a structured file format called YAML. This file format can store our data, making our Vagrantfile finally clean.</p>
  <p>This is how it works: YAML files support simple variables, arrays, hashes and nesting, without much hassle (given you get familiar to the picky format). And Ruby can load an YAML file into a variable. So, all we have to do is to create a data file for each data structure, then load them in the Vagrantfile. With only code.</p>
  <p>But how does a YAML file look like? Let's get some examples:</p>

  <p>An array</p>
  <pre>
  ---
  # My list
  - Array element 1
  - Array element 2
  </pre>

  <p>A hash</p>
  <pre>
  ---
  # My mapping
  key_1: value_1
  key_2: value_2
  </pre>

  <p>A disturbing mess</p>
  <pre>
  ---
  # A hash of arrays
  key_1:
    - value_1
    - value_2
  key_2:
    - value_1
    - value_2
  # An array of hashes
  - key_1: value_1
  - key_2: value_2
  - key_3:      # Who said all items should be equal?
    - value 3_1
    - value 3_2
  # Is this trip really necessary?
  key_1:
    key_1_1:
    - value_1_1_1
    - value_1_1_2
    key_1_2:
    - value_1_2_1
    - value_1_2_2
  key_2:
    key_2_1:
    - value_2_1_1
    - value_2_1_2
    key_2_2:
    - value_2_2_1
    - value_2_2_2
  # Yes, comments - Both inline and standalone
  # Try this into the hanging hash from part 2
  </pre>

  <p>Things to note:</p>
  <ul>
    <li>The first line has 3 dashes. This tells the OS it's a YAML file. Not quite a strong requirement, but highly recommended.</li>
    <li>Arrays have items prepended by <b>one</b> dash and <b>one</b> space. I do mean one. Remember: YAML is picky.</li>
    <li>Hashes have keys appended by a colon, followed by the value. There must be space(s) before the value. Remember: YAML is picky.</li>
    <li><b>Spaces in line beginnings are absolutely critical</b>. Use exactly two for each depth level. Variable names use no spaces, array values and hash keys use two, nested items use four, and so on. I might not have warned you, but YAML is picky.</li>
  </ul>

  <p>For real YAML learning, check out:</p>
  <ul>
    <li>This <a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">nice overview</a> from Ansible docs. It is quite a thorough overview, but still a simple and light-reading one.</li>
    <li>A <a href="https://www.tutorialspoint.com/yaml/index.htm">full tutorial</a> from Tutorials Point. Walks you through everything (I guess).</li>
    <li>The <a href="https://yaml.org/spec/1.2/spec.html">official manual</a>. Official manuals should always be at hand.</li>
  </ul>

  <p>Now, a nice trick. Ruby supports loading a YAML file into a variable. And also the other way round: dumping a variable into an YAML file. This can help a lot for our conversion:</p>
  <pre>
  ruby -e '
    require "yaml"
    puts YAML.dump({
      "key_1" => {
        "key_1_1" => [
          "item_1_1_1",
          "item_1_1_2"
        ],
        "key_1_2" => [
          "item_1_2_1",
          "item_1_2_2"
        ]
      },
      "key_2" => {
        "key_2_1" => [
          "item_2_1_1",
          "item_2_1_2"
        ],
        "key_2_2" => [
          "item_2_2_1",
          "item_2_2_2"
        ]
      }
    })
  '
  ---
  key_1:
    key_1_1:
    - item_1_1_1
    - item_1_1_2
    key_1_2:
    - item_1_2_1
    - item_1_2_2
  key_2:
    key_2_1:
    - item_2_1_1
    - item_2_1_2
    key_2_2:
    - item_2_2_1
    - item_2_2_2
  </pre>
  <p>Do it with any variable and see the results. Helps understanding YAML syntax.</p>

  <h2 id="together">Putting pieces together</h2>
  <p>Let's use the dump feature with the hash from our Vagrantfile. But, instead of seeing the output in the screen, let's write it to a virtual machines list file:</p>
  <pre>
    # A config dir in our project. What better name then "etc"?
    mkdir etc

    ruby -e "
      require 'yaml'
      IO.write('etc/vms.yaml', YAML.dump({
        'vm_1' => {
          :box => 'ARTACK/debian-jessie',
          :ip => '192.168.1.2'
        },
        'vm_2' => {
          :box => 'ARTACK/debian-jessie',
          :ip => '192.168.1.3'
        },
        'vm_3' => {
          :box => 'centos/7',
        }
      }))
    "

    cat etc/vms.yaml
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ip: 192.168.1.2
    vm_2:
      :box: ARTACK/debian-jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos/7
  </pre>

  <p>Nice! Half way done. Now on the other half: instructing Vagrant to read the file. It's the same, but the other way round:</p>
  <blockquote>We'll load the data into constants - just begin variables names with capitals and Ruby knows they're constants. There's no sense in changing their values thoughout the Vagrantfile.</blockquote>
  <pre>
    require 'yaml'
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
        end
      end
    end
  </pre>

  <p>Done! We have two slim and readable files, one with code and another one with data. You don't touch the Vagrantfile anymore to change VMs.</p>

  <h3 id="settings">More settings</h3>

  <p>Yes, sure a virtual machine is not about only name and IPs. Maybe you need to change RAM and/or CPU settings, for example?</p>

  <pre>
    require 'yaml'
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
          end
        end
      end
    end
  </pre>

  <p>Then, in the data file:</p>
  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
    vm_3:
      :box: centos/7
      :cpu: 2
  </pre>

  <p>In my case, I needed some VirtualBox custom settings. In Vagrant, this is done by passing a setting name and a value into <code>virtualbox.customize</code> tag.</p>

  <pre>
    require 'yaml'
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
            confs[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if confs.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>That was the code, so the settings themselves are irrelevant (no data in code!). Now, in the datafile, let's disable USB and VirtualBox Remote Desktop Extension, which already gave me pain in some VMs:</p>
  <blockquote>For the custom settings, we need names and values, which means a hash</blockquote>
  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_3:
      :box: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h3 id="datafiles">More data files</h3>

  <p>I heard you say "Hey, there's too much repetition in the data files!". That makes me proud of you.</p>
  <p>Yes, there are settings that will repeat. All VMs from the same box use at least the same box name and version. Sometimes, same resources and/or custom settings. Why repeat them all if we can have a data file for the boxes themselves?</p>

  <h4>Boxes data file</h4>
  <pre>
    ---
    debian_jessie:
      :name: ARTACK/debian-jessie
      :ram: 256
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    centos_7:
      :name: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h4>VMs data file</h4>
  <pre>
    ---
    vm_1:
      :box: debian_jessie
      :ip: 192.168.1.2
    vm_2:
      :box: debian_jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos_7
  </pre>

  <h4>Then, the Vagrantfile</h4>
  <pre>
    require 'yaml'
    BOXES = YAML.load_file('etc/boxes.yaml')
    VMS = YAML.load_file('etc/vms.yaml')

    Vagrant.configure("2") do |config|
      VMS.each do |name, confs|
        config.vm.define name do |vm|
          config.vbguest.auto_update = false
          box = BOXES[confs[:box]]
          vm.vm.box = box[:name]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = box[:ram] if box.has_key?(:ram)
            virtualbox.cpus = box[:cpu] if box.has_key?(:cpu)
            box[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if box.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>There's no hard line telling which files you should have and which data should be in each one. Go for the best bet between flexibility and simplicity.</p>
  <br>
  <p>Now we have 3 files with less than 20 lines each, all of them quite readable, and that gets us 3 VMs with different OSs, RAM and CPU settings, IP and provider specific stuff. And that we can very easily change, extend and/or reuse. Happy? Me too.</p>

  <h2 id="where">Where do we go from here?</h2>

  <p>What else can go in its own file and be consumed by the code? Maybe common hardware settings, network, some provisioning?</p>
  <p>Look for repeating patterns. We took code and data apart at all when it became clear that the code was almost the same to all VMs. Then created the boxes file when VMs settings also seemed repetitive. That's the way to go.</p>
  <p>It's not a good idea, though, to place every single repetiion pattern in distinct files. In some cases, you can end up with too many files with too little content and a file and variable maze to develop in.</p>
  <p>The most important thing to keep in mind about dividing all data in their files is that this should always make maintenance easier. Also, that other people who are not Ruby developers should be able to use your Vagrantfile. If you changed the data architecture, and it seems more complicated, it probably is. Even more to those who didn't write it. Rethink or discard.</p>

  <p>Now you know why and how to separate data from code, hands on! Happy Vagrantfiles!</p>

</body>
