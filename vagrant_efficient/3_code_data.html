---
layout: default
---

<body>
  <a href="3_code_data_pt.html">Português</a>

  <h1>Efficient Vagrantfiles – Part 3 – Code and data separation</h1>

  <p>In the <a href="2_ruby.html">second part</a> of this series, we got rid of lots of repeated code (and open doors for typing mistakes) by using arrays, hashes, loops and conditionals. Now, let's get our code cleaner and make maintenance more focused by getting code and data where each one belongs.</p>

  <ol>
    <li><a href="#tldr">TL;DR</a></li>
    <li><a href="#problem">Problem - messing with code to each environment change</a></li>
    <li><a href="#solution">Solution - each thing where it belongs</a>
      <ol>
        <li><a href="#variables">Variables versus logic</a></li>
        <li><a href="#yaml">Yaml</a></li>
      </ol>
    </li>
    <li><a href="#together">Putting pieces together</a></li>
    <li><a href="#where">Where do we go from here?</a></li>
  </ol>

  <h2 id="#tldr">TL;DR</h2>
  <h2 id="#problem">Problem - messing with code to each environment change</h2>

  <p>Your environment will change. Period. You might have to test an application's new version, or debug something in it, or try it in more OS options, or update boxes, etc. That's one of the main reasons you're using Vagrant in first place. In the common Vagrant use, every change means editing your Vagrantfile. This means trouble because:</p>
  <ul>
    <li>You end up sometimes having a big Vagrantfile with everything in it. Changing things becomes increasingly more difficult.</li>
    <li>When you have to think about code, you see data too. When you edit code, you risk messing data too. And vice-versa.</li>
    <li>Reusing Vagrantfiles becomes tedious - you have to remove all original data from the cloned Vagrantfile.</li>
    <li>Version tracking becomes a mess - no matter what had to change, your versioning system will always show the same change: Vagrantfile.</li>
  </ul>

  <h2 id="#solution">Solution - each thing where it belongs</h2>

  <p>If the problem is data and code mixed up, the solution is obvious: let's take them apart. We'll accomplish this in two steps: taking data and code to different Vagrantfile sections, then actually removing data from it.</p>

  <h3 id="#variables">Variables versus logic</h3>

  <p>The first part is fairly easy. For us to move data upwards in the Vagrantfile, all we have to do is setting variables before we write logic. Like:</p>

  <pre>
  # Data and code together
  $ ruby -e '
  {1 => "a", 2 => "b", 3 => "c"}.each do |key, value|
    puts "Key: #{key} - Value: #{value}"
  end
  '
  Key: 1 - Value: a
  Key: 2 - Value: b
  Key: 3 - Value: c

  # Data first, stored in a variable, then the code using it
  $ ruby -e '
  stuff = {1 => "a", 2 => "b", 3 => "c"}
  # Whatever
  stuff.each do |key, value|
    puts "Key: #{key} - Value: #{value}"
  end
  '
  Key: 1 - Value: a
  Key: 2 - Value: b
  Key: 3 - Value: c
  </pre>

  <p>I agree it didn't get quite neater - it got somewhat longer indeed. But it is more organized and focused. We just don't have a method and a code block around when we have to think about the data, nor a hash, or whatever data structure, when we have to think about the code. Just think about the huge hash we were dealing with in the last example of part 2, and the advantage becomes more clear.</p>

  <h3 id="#yaml">Yaml</h3>

  <p>We still have code and data in the same file. Fortunately, we don't have to. Ruby has native support for a structured file format called YAML. This file format can store our data, making our Vagrantfile finally clean.</p>
  <p>This is how it works: YAML files support simple variables, arrays, hashes and nesting, without much hassle (given you get familiar to the picky format). And Ruby can load an YAML file into a hash. So, all we have to do is to create a data file for each data structure, then load them in the Vagrantfile. With only code.</p>
  <p>But how does a YAML file look like? Let's get some examples:</p>

  <p>An array</p>
  <pre>
  ---
  # My list
  - Array element 1
  - Array element 2
  </pre>

  <p>A hash</p>
  <pre>
  ---
  # My mapping
  key_1: value_1
  key_1: value_1
  </pre>

  <p>A disturbing mess</p>
  <pre>
  ---
  # A hash of arrays
  key_1:
    - value_1
    - value_2
  key_2:
    - value_1
    - value_2
  # An array of hashes
  - key_1: value_1
  - key_2: value_2
  - key 3:      # Who said all items should be equal?
    - value 3_1
    - value 3_2
  # Is this trip really necessary?
  key_1:
    key_1_1:
    - value_1_1_1
    - value_1_1_2
    key_1_2:
    - value_1_2_1
    - value_1_2_2
  key_2:
    key_2_1:
    - value_2_1_1
    - value_2_1_2
    key_2_2:
    - value_2_2_1
    - value_2_2_2
  # Yes, comments. Both inline and standalone. Try this into the hanging hash from part 2.
  </pre>

  <p>Things to note:</p>
  <ul>
    <li>The first line has 3 dashes. This tells the OS it's a YAML file. Not quite a strong requirement, but highly recommended.</li>
    <li>Arrays have items prepended by <b>one</b> dash and <b>one</b> space. I do mean one. Remember: YAML is picky.</li>
    <li>Hashes have keys appended by a colon, followed by the value. There must be space(s) before the value. Remember: YAML is picky.</li>
    <li><b>Spaces in line beginnings are absolutely critical</b>. Use exactly two for each depth level. First-order variables use no spaces, key values use two, nested key values use four, and so on. I might not have warned you, but YAML is picky.</li>
  </ul>

  <p>For real YAML learning, check out:</p>
  <ul>
    <li>This <a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">nice overview</a> from Ansible docs. It is quite a thorough overview, but still a simple and light-reading one.</li>
    <li>A <a href="https://www.tutorialspoint.com/yaml/index.htm">full tutorial</a> from Tutorials Point. Walks you through everything (I guess).</li>
    <li>The <a href="https://yaml.org/spec/1.2/spec.html">official manual</a>. Official manuals should always be at hand.</li>
  </ul>

  <p>Now, a nice trick. Ruby supports loading a YAML file into a variable. And also the other way round: dumping a variable into an YAML file. This can help a lot for our conversion:</p>
  <pre>
  ruby -e '
    require "yaml"
    puts YAML.dump({
      "key_1" => {
        "key_1_1" => [
          "item_1_1_1",
          "item_1_1_2"
        ],
        "key_1_2" => [
          "item_1_2_1",
          "item_1_2_2"
        ]
      },
      "key_2" => {
        "key_2_1" => [
          "item_2_1_1",
          "item_2_1_2"
        ],
        "key_2_2" => [
          "item_2_2_1",
          "item_2_2_2"
        ]
      }
    })
  '
  ---
  key_1:
    key_1_1:
    - item_1_1_1
    - item_1_1_2
    key_1_2:
    - item_1_2_1
    - item_1_2_2
  key_2:
    key_2_1:
    - item_2_1_1
    - item_2_1_2
    key_2_2:
    - item_2_2_1
    - item_2_2_2
  </pre>
  <p>Do it with any variable and see the results. Helps understanding YAML syntax.</p>

  <h2 id="#together">Putting pieces together</h2>
  <p>Let's use the dump feature with the hash from our Vagrantfile. But, instead of seeing the output in the screen, let's dump it into a virtual machines list file:</p>
  <pre>
    mkdir etc   # A config dir in our Vagrant project. What better name then "etc"?

    ruby -e "
      require 'yaml'
      IO.write('etc/mvs.yaml', YAML.dump({
        'vm_1' => {
          :box => 'ARTACK/debian-jessie',
          :ip => '192.168.1.2'
        },
        'vm_2' => {
          :box => 'ARTACK/debian-jessie',
          :ip => '192.168.1.3'
        },
        'vm_3' => {
          :box => 'centos/7',
        }
      }))
    "

    cat etc/mvs.yaml
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ip: 192.168.1.2
    vm_2:
      :box: ARTACK/debian-jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos/7
  </pre>

  <p>Nice! Half way done. Now on the other half: instructing Vagrant to read the file. It's the same, but the other way round:</p>
  <blockquote>We'll load the data into constants, which are variables with names beginning with capitals. There's no sense in changing their values thoughout the Vagrantfile.</blockquote>
  <pre>
    require 'yaml'
    MVS = YAML.load_file('etc/mvs.yaml')

    Vagrant.configure("2") do |config|
      MVS.each do |nome, confs|
        config.vm.define nome do |vm|
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
        end
      end
    end
  </pre>

  <p>Done! We have two slim and readable files, one with code and another one with data. You don't touch the Vagrantfile anymore to change VMs.</p>

  <h2 id="#where">Where do we go from here?</h2>
</body>
