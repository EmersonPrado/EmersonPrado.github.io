---
layout: default
---

<body>
  <a href="../index_pt.html">Página inicial</a><br>
  <a href="3_code_data.html">English</a>

  <h1>Vagrantfiles eficientes – Parte 3 – Separação de código e dados</h1>

  <p>Na <a href="2_ruby_pt.html">parte 2</a> desta série de artigos, nos livramos de muita repetição de código (e de muito lugar bom pra erros de digitação) usando <i>arrays</i>, <i>hashes</i>, laços e condicionais. Agora, vamos tornar o código mais limpo e a manutenção mais focada, colocando código e dados no lugar de cada um.</p>

  <ol>
    <li><a href="#tldr">TL;DR</a></li>
    <li><a href="#problema">Problema - mexer no código a cada mudança no ambiente</a></li>
    <li><a href="#solucao">Solução - cada macaco no seu galho</a>
      <ol>
        <li><a href="#variaveis">Variáveis versus lógica</a></li>
        <li><a href="#yaml">Yaml</a><ol>
          <li><a href="#yaml_basico">O básico</a></li>
          <li><a href="#yaml_aninhamento">Aninhamento</a></li>
          <li><a href="#yaml_dicas">Dicas</a></li>
        </ol></li>
      </ol>
    </li>
    <li><a href="#junto">Tudo ao mesmo tempo agora</a>
      <ol>
        <li><a href="#confs">Mais configurações</a></li>
        <li><a href="#arq_dados">Mais arquivos de dados</a></li>
      </ol>
    </li>
    <li><a href="#depois">E depois?</a></li>
  </ol>

  <h2 id="tldr">TL;DR</h2>

  <p>Se você já conhece arquivos YAML, e sabe como importá-los no código Ruby, talvez você possa pular esta parte dos artigos, e fazer tudo funcionar com o resumo abaixo.</p>

  <p>Na parte 2, ficamos com um <i>hash</i> com dados de todas as MVs, e um código com um laço iterando a partir do <i>hash</i>. A diferença entre o código e os dados está razoavelmente visível. Vamos criar o arquivo externo <code>etc/mvs.yaml</code>, no formato YAML, com estes dados e mais (detalhes a mais que eu costumo precisar):</p>

  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_3:
      :box: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <p>Aí, no Vagrantfile, é só carregar o arquivo numa variável, e usar a variável no laço, consumindo os vários valores aninhados:</p>

  <pre>
    require 'yaml'
    MVS = YAML.load_file('etc/mvs.yaml')

    Vagrant.configure("2") do |config|
      MVS.each do |nome, confs|
        config.vm.define nome do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
            confs[:custom].each do |custom, valor|
              virtualbox.customize ['modifyvm', :id, custom, valor]
            end if confs.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>Podemos dividir em mais arquivos, se um arquivo começa a ficar repetitivo. Você deve ter percebido (palmas pra você!) que o arquivo das MVs tem praticamente os mesmos dados para as MVs que usam o mesmo <i>box</i>. Então, vamos dividir em 2 arquivos - MVs e <i>boxes</i>:</p>

  <h4>Arquivo dos <i>Boxes</i> - <code>etc/boxes.yaml</code></h4>
  <pre>
    ---
    debian_jessie:
      :nome: ARTACK/debian-jessie
      :ram: 256
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    centos_7:
      :nome: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h4>Arquivo das MVs - <code>etc/mvs.yaml</code></h4>
  <pre>
    ---
    vm_1:
      :box: debian_jessie
      :ip: 192.168.1.2
    vm_2:
      :box: debian_jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos_7
  </pre>

  <h4>Aí, no Vagrantfile</h4>
  <pre>
    require 'yaml'
    BOXES = YAML.load_file('etc/boxes.yaml')
    MVS = YAML.load_file('etc/mvs.yaml')

    Vagrant.configure("2") do |config|
      MVS.each do |nome, confs|
        config.vm.define nome do |vm|
          config.vbguest.auto_update = false
          box = BOXES[confs[:box]]
          vm.vm.box = box[:nome]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = box[:ram] if box.has_key?(:ram)
            virtualbox.cpus = box[:cpu] if box.has_key?(:cpu)
            box[:custom].each do |custom, valor|
              virtualbox.customize ['modifyvm', :id, custom, valor]
            end if box.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>Complexidade é o limite. Você pode ter só um arquivo de dados, ou dividir os dados em vários arquivos. Procure equilibrar concisão e simplicidade. O objetivo é facilitar a compreensão e a manutenção do conjunto, inclusive por outros, muitas vezes não programadores. Bom senso é seu amigo!</p>

  <h2 id="problema">Problema - mexer no código a cada mudança no ambiente</h2>

    <p>Seu ambiente vai mudar. Ponto final. Talvez você precise testar uma versão nova de uma aplicação, ou depurar algum problema nela, ou testá-la em outras opções de SO, ou atualizar <i>boxes</i>, etc. Esse é, afinal, um dos principais motivos pra você usar o Vagrant. Na forma corriqueira de uso do Vagrant, cada mudança implica em editar o Vagrantfile. Isto traz algumas dores de cabeça:</p>
    <ul>
      <li>Você pode acabar tendo um Vagrantfile enorme, com tudo dentro. Mudar alguma coisa nele vai ficando cada vez mais difícil.</li>
      <li>Quando você precisa mexer no código, você está cercado de dados. E vice-versa. É mais difícil focar em um - e mais fácil "esbarrar" no outro.</li>
      <li>O reúso de Vagrantfiles se torna trabalhoso - é necessário copiar e colar Vagrantfiles e editar manualmente as diferenças.</li>
      <li>O versionamento fica confuso - pra qualquer mudança, seu sistema de versionamento sempre indicará a mesma alteração: o Vagrantfile.</li>
    </ul>

  <h2 id="solucao">Solução - cada macaco no seu galho</h2>

  <p>Se o problema é código e dados misturados, a solução é simples: basta separá-los. Vamos fazer isso em duas etapas: colocar código e dados em seções diferentes do Vagrantfile, depois remover os dados de vez.</p>

  <h3 id="variaveis">Variáveis versus lógica</h3>

  <p>A primeira parte é fácil. Pra mover os dados pra cima no Vagrantfile, é só criar variáveis com os dados, antes de escrever a lógica. Assim:</p>

  <pre>
  # Código e dados juntos
  $ ruby -e '
  {1 => "a", 2 => "b", 3 => "c"}.each do |chave, valor|
    puts "Chave: #{chave} - Valor: #{valor}"
  end
  '
  Chave: 1 - Valor: a
  Chave: 2 - Valor: b
  Chave: 3 - Valor: c

  # Primeiro os dados, em uma variável, depois o cógigo que a usa
  $ ruby -e '
  coisas = {1 => "a", 2 => "b", 3 => "c"}
  # Qualquer coisa
  coisas.each do |chave, valor|
    puts "Chave: #{chave} - Valor: #{valor}"
  end
  '
  Chave: 1 - Valor: a
  Chave: 2 - Valor: b
  Chave: 3 - Valor: c
  </pre>

  <p>OK, não ficou mais enxuto - na verdade, ficou até um pouco maior. Mas mais organizado e focado. Agora, na hora de mexer nos dados, não estamos cercados de comandos, nem cercados de <i>arrays</i> e <i>hashes</i> na hora de mexer na lógica. Lembre do <i>hash</i> enorme que tínhamos no último exemplo da parte 2, e a vantagem fica mais clara.</p>

  <h3 id="yaml">Yaml</h3>

  <p>Os dados e o código ainda estão no mesmo arquivo. Felizmente, não precisam. O Ruby suporta nativamente um formato de arquivo de dados estruturados: YAML. Este formato pode guardar os dados, deixando nosso Vagrantfile finalmente limpo.</p>
  <p>Funciona assim: arquivos YAML podem conter um objeto Ruby, que pode ser um valor simples, um <i>array</i>, um <i>hash</i> ou <i>arrays</i>/<i>hashes</i> aninhados, com alguma facilidade (desde que você se acostume com o formato exigente). E o Ruby carrega arquivos YAML em variáveis.</p>
  <p>Então, é só criar um arquivo pra cada estrutura de dados, e depois carregar no Vagrantfile. Que agora só terá código.</p>

  <h4 id="yaml_basico">O Básico</h4>

  <h4 id="yaml_aninhamento">Aninhamento</h4>

  <h4 id="yaml_dicas">Dicas</h4>

  <h2 id="junto">Tudo ao mesmo tempo agora</h2>

  <p>Vamos usar o comando <code>dump</code> com o <i>hash</i> do nosso Vagrantfile. Mas, em vez de ver o resultado na tela, vamos mandar pra um arquivo com a lista de máquinas virtuais:</p>
  <pre>
    # Um diretório de configurações no nosso projeto
    # Que nome seria melhor que "etc"?
    mkdir etc

    ruby -e "
      require 'yaml'
      IO.write('etc/mvs.yaml', YAML.dump({
        'vm_1' => {
          :box => 'ARTACK/debian-jessie',
          :ip => '192.168.1.2'
        },
        'vm_2' => {
          :box => 'ARTACK/debian-jessie',
          :ip => '192.168.1.3'
        },
        'vm_3' => {
          :box => 'centos/7'
        }
      }))
    "

    cat etc/mvs.yaml
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ip: 192.168.1.2
    vm_2:
      :box: ARTACK/debian-jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos/7
  </pre>

  <p>Boa! Meio caminho andado. Agora a outra metade: orientando o Vagrant a ler o arquivo. É a mesma coisa, só que ao contrário:</p>
  <blockquote>Vamos colocar os dados em constantes - é só iniciar os nomes das variáveis com maiúsculas, e o Ruby sabe que são constantes. Não faz sentido mudar estes valores ao longo do Vagrantfile.</blockquote>
  <pre>
    require 'yaml'
    MVS = YAML.load_file('etc/mvs.yaml')

    Vagrant.configure("2") do |config|
      MVS.each do |nome, confs|
        config.vm.define nome do |vm|
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
        end
      end
    end
  </pre>

  <p>Pronto! Dois arquivos enxutos e fáceis de ler, um com código e outro com dados. Você não vai mais precisar mexer no Vagrantfile pra alterar as MVs.</p>

  <h3 id="confs">Mais configurações</h3>

  <p>É claro que uma máquina virtual não é feita só de nome e IPs. Que tal mexer, por exemplo, nas configurações de RAM e/ou CPU?</p>

  <pre>
    require 'yaml'
    MVS = YAML.load_file('etc/mvs.yaml')

    Vagrant.configure("2") do |config|
      MVS.each do |nome, confs|
        config.vm.define nome do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
          end
        end
      end
    end
  </pre>

  <p>Então, o arquivo de dados fica:</p>
  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
    vm_3:
      :box: centos/7
      :cpu: 2
  </pre>

  <p>No meu caso, também precisei modificar configurações específicas do VirtualBox. No Vagrant, a diretiva que faz isso é a <code>virtualbox.customize</code>.</p>

  <pre>
    require 'yaml'
    MVS = YAML.load_file('etc/mvs.yaml')

    Vagrant.configure("2") do |config|
      MVS.each do |nome, confs|
        config.vm.define nome do |vm|
          config.vbguest.auto_update = false
          vm.vm.box = confs[:box]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = confs[:ram] if confs.has_key?(:ram)
            virtualbox.cpus = confs[:cpu] if confs.has_key?(:cpu)
            confs[:custom].each do |custom, valor|
              virtualbox.customize ['modifyvm', :id, custom, valor]
            end if confs.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>Mudamos o código, que continua independente dos dados (dados fora do código!). Agora, no arquivo de dados, vamos desabilitar USB e a VirtualBox Remote Desktop Extension, que já me causaram problemas em algumas MVs:</p>
  <blockquote>As configurações personalizadas exigem nomes e valores - ou seja, um <i>hash</i> como valor da chave ':custom'</blockquote>
  <pre>
    ---
    vm_1:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_2:
      :box: ARTACK/debian-jessie
      :ram: 256
      :ip: 192.168.1.3
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    vm_3:
      :box: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h3 id="arq_dados">Mais arquivos de dados</h3>

  <p>Eu ouvi você dizer "Peraí! Os arquivos de dados estão muito repetitivos!". Fiquei orgulhoso de você!</p>
  <p>Sim, muitas configurações serão parecidas. Todas as MVs de um mesmo <i>box</i> têm, pelo menos, o mesmo nome e versão de <i>box</i>. Às vezes, os mesmos recursos e/ou configurações personalizadas. Pra que repetir configurações de MVs se podemos ter um arquivo pros próprios <i>boxes</i>?</p>

  <h4>Arquivo de dados dos <i>boxes</i></h4>
  <pre>
    ---
    debian_jessie:
      :nome: ARTACK/debian-jessie
      :ram: 256
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
    centos_7:
      :nome: centos/7
      :cpu: 2
      :custom:
        '--usb': 'off'
        '--usbehci': 'off'
        '--usbxhci': 'off'
        '--vrde': 'off'
  </pre>

  <h4>Arquivo de dados das MVs</h4>
  <pre>
    ---
    vm_1:
      :box: debian_jessie
      :ip: 192.168.1.2
    vm_2:
      :box: debian_jessie
      :ip: 192.168.1.3
    vm_3:
      :box: centos_7
  </pre>

  <h4>Então, no Vagrantfile:</h4>
  <pre>
    require 'yaml'
    BOXES = YAML.load_file('etc/boxes.yaml')
    MVS = YAML.load_file('etc/mvs.yaml')

    Vagrant.configure("2") do |config|
      MVS.each do |nome, confs|
        config.vm.define nome do |vm|
          config.vbguest.auto_update = false
          box = BOXES[confs[:box]]
          vm.vm.box = box[:nome]
          vm.vm.network "private_network", ip: confs[:ip] if confs.has_key?(:ip)
          vm.vm.provider 'virtualbox' do |virtualbox|
            virtualbox.memory = box[:ram] if box.has_key?(:ram)
            virtualbox.cpus = box[:cpu] if box.has_key?(:cpu)
            box[:custom].each do |custom, value|
              virtualbox.customize ['modifyvm', :id, custom, value]
            end if box.has_key?(:custom)
          end
        end
      end
    end
  </pre>

  <p>Não há fórmula mágica que determine quantos arquivos e o que colocar em cada um. Use o bom senso, equilibrando flexibilidade e simplicidade.</p>
  <br>
  <p>Agora temos 3 arquivos com menos de 20 linhas cada um, todos fáceis de ler, e que resultam em 3 MVs com configurações múltiplas de SO, RAM, CPU, IP e particularidades do virtualizador. E que são fáceis de mudar, expandir e/ou reutilizar. Satisfeito? Eu também.</p>

  <h2 id="depois">E depois?</h2>

  <p>Que outros dados podem ser colocados em arquivos separados para o código usar? Talvez algumas configurações de <i>hardware</i>, rede, algum provisionamento?</p>
  <p>Procure padrões de repetição. Só conseguimos começar a separar dados de código quando ficou claro que o código era praticamente o mesmo para todas as MVs. Pudemos criar arquivos com dados dos <i>boxes</i> porque vimos que as configurações das MVs também se repetiam. É por aí.</p>
  <p>Isso não quer dizer que seja uma boa ideia colocar cada mínima repetição em um arquivo separado. Dependendo do caso, você pode acabar com arquivos demais, com conteúdo de menos, e desenvolvendo sobre um emaranhado de arquivos e variáveis.</p>
  <p>O que você precisa ter sempre em mente é que dividir dados em arquivos deve deixar a manutenção mais fácil. Outros, às vezes não programadores Ruby, e até você meses depois, precisam conseguir (re)usar seu Vagrantfile. Se você mudou a arquitetura dos dados, e desconfia que ficou mais complicada, provavelmente ficou mesmo - Principalmente pra quem não criou os arquivos. Refaça ou desfaça.</p>

  <p>Agora que já sabe por que e como separar os dados do código, mãos à obra! Bons Vagrantfiles!</p>

</body>
