---
layout: default
---

<body>
  <a href="../index_pt.html">Página inicial</a><br>
  <a href="3_code_data.html">English</a>

  <h1>Vagrantfiles eficientes – Parte 3 – Separação de dados e código</h1>

  <p>Na <a href="2_ruby_pt.html">parte 2</a> desta série de artigos, nos livramos de muita repetição de código (e de muito lugar bom pra erros de digitação) usando <i>arrays</i>, <i>hashes</i>, laços e condicionais. Agora, vamos tornar o código mais limpo e a manutenção mais focada, colocando código e dados no lugar de cada um.</p>

  <ol>
    <li><a href="#tldr">TL;DR</a></li>
    <li><a href="#problema">Problema - mexer no código a cada mudança no ambiente</a></li>
    <li><a href="#solucao">Solução - cada macaco no seu galho</a>
      <ol>
        <li><a href="#variaveis">Variáveis versus lógica</a></li>
        <li><a href="#yaml">Yaml</a></li>
      </ol>
    </li>
    <li><a href="#junto">Tudo ao mesmo tempo agora</a>
      <ol>
        <li><a href="#confs">Mais configurações</a></li>
        <li><a href="#arq_dados">Mais arquivos de dados</a></li>
      </ol>
    </li>
    <li><a href="#depois">E depois?</a></li>
  </ol>

  <h2 id="#tldr">TL;DR</h2>
  <h2 id="#problema">Problema - mexer no código a cada mudança no ambiente</h2>

    <p>Seu ambiente vai mudar. Ponto final. Talvez você precise testar uma versão nova de uma aplicação, ou depurar algum problema nela, ou testá-la em outras opções de SO, ou atualizar <i>boxes</i>, etc. Esse é, afinal, um dos principais motivos pra você usar o Vagrant. Na forma corriqueira de uso do Vagrant, cada mudança implica em editar o Vagrantfile. Isto traz algumas dores de cabeça:</p>
    <ul>
      <li>Você pode acabar tendo um Vagrantfile enorme, com tudo dentro. Mudar alguma coisa nele vai ficando cada vez mais difícil.</li>
      <li>Quando você precisa pensar no código, você também vê dados. Quando você edita o código, corre o risco de "esbarrar" nos dados. E vice-versa.</li>
      <li>O reúso de Vagrantfiles se torna trabalhoso - é necessário copiar e colar Vagrantfiles e editar manualmente as diferenças.</li>
      <li>O versionamento fica confuso - pra qualquer mudança, seu sistema de versionamento sempre indicará a mesma alteração: o Vagrantfile.</li>
    </ul>

  <h2 id="#solucao">Solução - cada macaco no seu galho</h2>

  <p>Se o problema é data e código misturados, a solução é simples: basta separá-los. Vamos fazer isso em duas etapas: colocar dados e código em seções diferentes do Vagrantfile, depois remover os dados de vez.</p>

  <h3 id="#variaveis">Variáveis versus lógica</h3>

  <p>A primeira parte é fácil. Pra mover os dados pra cima no Vagrantfile, é só criar variáveis com os dados, antes de escrever a lógica. Assim:</p>

  <pre>
  # Dados e código juntos
  $ ruby -e '
  {1 => "a", 2 => "b", 3 => "c"}.each do |chave, valor|
    puts "Chave: #{chave} - Valor: #{valor}"
  end
  '
  Chave: 1 - Valor: a
  Chave: 2 - Valor: b
  Chave: 3 - Valor: c

  # Primeiro os dados, em uma variável, depois o cógigo que a usa
  $ ruby -e '
  coisas = {1 => "a", 2 => "b", 3 => "c"}
  # Qualquer coisa
  coisas.each do |chave, valor|
    puts "Chave: #{chave} - Valor: #{valor}"
  end
  '
  Chave: 1 - Valor: a
  Chave: 2 - Valor: b
  Chave: 3 - Valor: c
  </pre>

  <p>OK, não ficou mais enxuto - na verdade, ficou até um pouco maior. Mas mais organizado e focado. Agora, na hora de mexer nos dados, não estamos cercados de comandos, nem cercados de <i>arrays</i> e <i>hashes</i> na hora de mexer na lógica. Lembre do <i>hash</i> enorme que tínhamos no último exemplo da parte 2, e a vantagem fica mais clara.</p>

  <h3 id="#yaml">Yaml</h3>

  <p>Os dados e o código ainda estão no mesmo arquivo. Felizmente, não precisam. O Ruby suporta nativamente um formato de arquivo de dados estruturados: YAML. Este formato pode guardar os dados, finalmente limpando nosso Vagrantfile.</p>
  <p>Funciona assim: arquivos YAML podem conter variáveis simples, <i>arrays</i>, <i>hashes</i> e tudo isso aninhado, com alguma facilidade (desde que você se acostume com o formato detalhista). E o Ruby carrega arquivos YAML em <i>hashes</i>. Então, é só criar um arquivo pra cada estrutura de dados, e então carregar no Vagrantfile. Que agora só terá código.</p>
  <p>Mas como é a cara de um arquivo YAML? Alguns exemplos:</p>

  <p>Um <i>array</i></p>
  <pre>
  ---
  # Minha lista
  - Elemento 1
  - Elemento 2
  </pre>

  <p>Um <i>hash</i></p>
  <pre>
  ---
  # Meu mapeamento
  chave_1: valor_1
  chave_2: valor_2
  </pre>

  <p>Uma admirável loucura</p>
  <pre>
  ---
  # Um hash de arrays
  chave_1:
    - valor_1
    - valor_2
  chave_2:
    - valor_1
    - valor_2
  # An array of hashes
  - chave_1: valor_1
  - chave_2: valor_2
  - chave_3:    # Quem disse que todos os itens precisam ser iguais?
    - valor_3_1
    - valor_3_2
  # Essa viagem é realmente necessária?
  chave_1:
    chave_1_1:
    - valor_1_1_1
    - valor_1_1_2
    chave_1_2:
    - valor_1_2_1
    - valor_1_2_2
  chave_2:
    chave_2_1:
    - valor_2_1_1
    - valor_2_1_2
    chave_2_2:
    - valor_2_2_1
    - valor_2_2_2
  # Isso mesmo: comentários - Inline e em linhas separadas
  # Imagine isso no hash enorme da parte 2
  </pre>

  <p>Notar:</p>
  <ul>
    <li>A primeira linha tem 3 hífens. É isso que informa o SO que o arquivo é YAML. Não é uma exigência, mas é altamente recomendado.</li>
    <li>Os itens de <i>arrays</i> são precedidos de <b>um</b> hífen e <b>um</b> espaço. É um mesmo. Lembre-se: YAML é detalhista.</li>
    <li>As chaves de <i>arrays</i> são seguidas de dois pontos, seguido do valor. É necessário incluir espaço(s) antes do valor. Lembre-se: YAML é detalhista.</li>
    <li><b>Os espaços no início das linhas são absolutamente críticos</b>. Use exatamente dois para cada nível de aninhamento. Nomes de variáveis não usam espaços, valores de <i>arrays</i> e chaves de <i>hashes</i> usam dois, items aninhados usam quatro, e assim por diante. Não sei se eu avisei, mas YAML é detalhista.</li>
  </ul>

  <p>Dicas pra aprender YAML de verdade:</p>
  <ul>
    <li>Esta <a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">ótima introdução</a> da documentação do Ansible. É uma introdução bem abrangente, mas simples e de fácil leitura.</li>
    <li>Um <a href="https://www.tutorialspoint.com/yaml/index.htm">tutorial completo</a> do Tutorials Point. Passa por tudo (eu acho).</li>
    <li>O <a href="https://yaml.org/spec/1.2/spec.html">manual oficial</a>. Mantenha sempre manuais oficiais por perto.</li>
  </ul>

  <p>Um truque. O Ruby suporta carregar um arquivo YAML numa variável. E o contrário também: jogar uma variável em um arquivo YAML. Isso ajuda muito na conversão que vamos fazer:</p>
  <pre>
  ruby -e '
    require "yaml"
    puts YAML.dump({
      "chave_1" => {
        "chave_1_1" => [
          "item_1_1_1",
          "item_1_1_2"
        ],
        "chave_1_2" => [
          "item_1_2_1",
          "item_1_2_2"
        ]
      },
      "chave_2" => {
        "chave_2_1" => [
          "item_2_1_1",
          "item_2_1_2"
        ],
        "chave_2_2" => [
          "item_2_2_1",
          "item_2_2_2"
        ]
      }
    })
  '
  ---
  chave_1:
    chave_1_1:
    - item_1_1_1
    - item_1_1_2
    chave_1_2:
    - item_1_2_1
    - item_1_2_2
  chave_2:
    chave_2_1:
    - item_2_1_1
    - item_2_1_2
    chave_2_2:
    - item_2_2_1
    - item_2_2_2
  </pre>
  <p>Teste o resultado com várias variáveis. Ajuda muito a entender a sintaxe do YAML.</p>

  <h2 id="#junto">Tudo ao mesmo tempo agora</h2>
  <h2 id="#depois">E depois?</h2>
</body>
